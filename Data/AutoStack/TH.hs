{-# LANGUAGE LambdaCase      #-}
{-# LANGUAGE TemplateHaskell #-}

{-| To make full use of the code generated by this module you need to enable
    the following LANGUAGE extension in your code:

 @FlexibleContexts, FlexibleInstances, TemplateHaskell, UndecidableInstances, OverlappingInstances@
 -}

module Data.AutoStack.TH
    ( module Data.AutoStack.TH
    , bracket
    ) where

import Control.Monad.Catch (bracket)
import Data.Maybe (fromMaybe)
import Language.Haskell.TH

showLoc :: Loc -> String
showLoc loc = "<" ++ loc_filename loc ++ ">:" ++ show (loc_start loc)

{-|
   The 'mkRunComponents' function builds the 'runComponents' function.
   'runComponents' can be called with a tuple of 'Component's as argument
   For pretty printing the output use
   @putStrLn $( stringE . show =\<\< ppr \<$> mkRunComponents [| components  |] )@
   where @components = (Component .., Component .., ..)@
 -}
mkRunComponents :: Name -> Q [Dec]
mkRunComponents name = reify name >>= fromInfo
    where
    printError                = location >>= error . showLoc

    fromInfo (VarI _ typ _ _) = tupLength typ >>= \n -> return [mkFun n]
    fromInfo                _ = printError

    tupLength (TupleT  n)     = return n
    tupLength (AppT appt _)   = tupLength appt
    tupLength           _     = printError

    -- F: Function
    -- N: Name
    -- E: Expression
    -- P: Partial

    fargN           = mkName "f"
    appFN           = mkName "$"
    flipFN          = mkName "flip"
    bracketN        = mkName "bracket"
    allocCtorN      = mkName "Component"
    nthN v n        = mkName $ v ++ show n

    -- (Component a1 r1 rr1, Component a2 r2 rr2, ..)
    allocVarPs n    = [VarP (nthN "a" n), VarP (nthN "r" n), VarP (nthN "rr" n)]
    allocCtor n     = ConP allocCtorN (allocVarPs n)

    -- bracket a1 r1 $ \rs1 -> bracket a2 r2 $ \rs2 -> ..
    bracketPF n     = AppE (AppE (VarE bracketN) (VarE $ nthN "a" n)) (VarE $ nthN "r" n)
    bracketE n e    = UInfixE (bracketPF n) (VarE appFN) (LamE [VarP $ nthN "rs" n] e)

    -- build the bracket recursively
    mkBracketE n' n
        | n > n'    = runF n'
        | otherwise = bracketE n $ mkBracketE n' (n+1)

    -- .. $ flip rr2 rs2 $ flip rr1 rs1 $ f
    runPF n         = (AppE (AppE (VarE flipFN) (VarE $ nthN "rr" n)) (VarE $ nthN "rs" n))
    runF 0          = VarE fargN
    runF n          = UInfixE (runPF n) (VarE appFN) (runF (n-1))

    -- runComponents (Component ..) f = do
    funN            = mkName "runComponents"
    funPat n        = TupP $ [allocCtor n' | n' <- [1..n]]
    funBody n       = NormalB (DoE [NoBindS $ mkBracketE n 1])
    funClause n     = Clause [funPat n, VarP fargN] (funBody n) []
    mkFun n         = FunD funN [funClause n]

{-|
   Constructs a function called 'runWithComponents'.
   Similar to the 'mkRunComponents' function, but the 'Component's are already
   partially applied to the resulting function
 -}
mkRunWithComponents :: Name -> Q [Dec]
mkRunWithComponents name = sequence [funD (mkName "runWithComponents") [clse]]
    where
    funArgN = mkName "f'"
    runFunN = varE $ mkName "runComponents"
    body = normalB $ appE (appE runFunN $ varE name) (varE funArgN)
    clse = mkRunComponents name >>= \ds -> do
        clause [varP funArgN] body (map return ds)

type ClassName = String

type TransName = String

type MethodName = String

type FunctionName = String

mkTransClass :: (FunctionName -> MethodName)
             -> ClassName -- ^ @class Monad m => ClassName m where ..@
             -> TransName -- ^ @instance Monad m => ClassName (TransName m) where ..@
             -> [FunctionName] -- ^ @where mname_1 = fname_1; mname_2 = fname_2 ..@
             -> Q [Dec]
mkTransClass toMethod cn tn fns = mapM classDecs fns >>= return . (:[]) . classd

    where
    m = mkName "m"
    cname = mkName cn
    ctxt = [ClassP (mkName "Monad") [VarT m]]
    classd = ClassD ctxt cname [PlainTV m] []

    printError msg = error $ "cannot generate class method: " ++ msg -- show (ppr typ)

    classDecs fn = methodSig fn >>= return . SigD (mkName $ toMethod fn)

    methodSig fn = reify (mkName fn) >>= \case
        VarI _ typ _ _ -> maybe (printError $ show $ ppr typ) return $ scrapFunctionType typ
        info -> printError $ fn ++ " (info: " ++ show info ++ ")"

    scrapFunctionType = scrapTrans . scrapForall

    scrapForall (ForallT _ _ typ) = typ
    scrapForall typ               = typ

    scrapTrans (AppT t1 t2)
        | isTrans t1 = Just $ replaceMonad t2
        | isTrans t2 = Just $ replaceMonad t1
        | otherwise  = Just $ AppT (fromMaybe t1 $ scrapTrans t1) (fromMaybe t2 $ scrapTrans t2)
    scrapTrans _ = Nothing

    replaceMonad _ = VarT m

    isTrans (ConT name) = nameBase name == tn
    isTrans _           = False

{-|
 - @instance Monad m => ClassName (TransName m) where ..@
 - @instance (ClassName m, Monad (t m), MonadTrans t) => ClassName (t m) where ..@
 -}
mkTransInstances :: (FunctionName -> MethodName) -> ClassName -> TransName -> [FunctionName] -> Q [Dec]
mkTransInstances toMethod cn tn fns = sequence [liftInstance, bottomInstance]
    where
    m = mkName "m"
    t = mkName "t"
    liftN = mkName "lift"
    cname = mkName cn
    tname = mkName tn

    monad_cn_m_Cxt = classP (mkName cn) [varT m]
    monad_m_Cxt = classP (mkName "Monad") [(varT m)]
    monad_tm_Cxt = classP (mkName "Monad") [appT (varT t) (varT m)]
    monadTransCxt = classP (mkName "MonadTrans") [varT t]

    -- instance (MonadTrans t, MonadFoo m, Monad (t m)) => ClassName (t m) where
    liftCxt      = cxt [monad_cn_m_Cxt, monad_tm_Cxt, monadTransCxt]

    liftBodyArgs f 1 = appE (varE $ mkName f) (varE $ mkName "a1")
    liftBodyArgs f n = appE (liftBodyArgs f (n-1)) (varE $ mkName $ "a" ++ show n)

    liftBody f 0 = normalB $ appE (varE liftN) (varE $ mkName f)
    liftBody f n = normalB $ appE (varE liftN) (parensE $ liftBodyArgs f n)

    liftClause f = do
        n <- argCount f
        let args = [mkName ("a" ++ show i) | i <- [(1::Int)..n]]
        clause [varP p | p <- args] (liftBody f n) []

    liftFunDs    = [funD (mkName (toMethod fn)) [liftClause (toMethod fn)] | fn <- fns]
    liftInstance = instanceD liftCxt (appT (conT cname) (appT (varT t) (varT m))) liftFunDs

    argCount fname = reify (mkName fname) >>= \case
        VarI _ ty _ _ -> return $ countFunArgs ty
        ClassOpI _ ty _ _ -> return $ countFunArgs ty
        info -> error $ "no args for " ++ show info

    -- instance Monad m => ClassName (TransName m) where
    bottomCxt = cxt [monad_m_Cxt]
    bottomClause f = clause [] (normalB $ varE $ mkName f) []
    bottomFunDs = [funD (mkName (toMethod fn)) [bottomClause fn] | fn <- fns]
    bottomInstance = instanceD bottomCxt (appT (conT cname) (appT (conT tname) (varT m))) bottomFunDs

countFunArgs :: Num a => Type -> a
countFunArgs (ForallT _ _ t) = countFunArgs t
countFunArgs (AppT ArrowT _) = 1
countFunArgs (AppT t1 t2)    = countFunArgs t1 + countFunArgs t2
countFunArgs _               = 0
